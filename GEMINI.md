# 開発ガイドライン

## Next.js ベストプラクティス

### プロジェクトセットアップ

- **`create-next-app` の利用:** プロジェクトのセットアップには、`create-next-app` CLI ツールを使用します。
- **App Router の採用:** 新規プロジェクトでは App Router を積極的に採用します。
- **TypeScript の導入:** 型安全のために TypeScript を使用します。
- **ESLint の設定:** コード品質を保つために ESLint を導入し、`npm run lint` を定期的に実行します。
- **`src/` ディレクトリの使用:** アプリケーションのソースコードは `src/` ディレクトリ内に配置します。
- **絶対パスインポートの設定:** `tsconfig.json` で `paths` を設定し、`@/` から始まる絶対パスでモジュールをインポートします。

### ルーティングと構造

- **ファイルシステムベースのルーティング:** `app`ディレクトリ内にフォルダを作成し、`page.tsx`を配置してルートを定義します。
- **共有レイアウト:** 複数ページで共通の UI は`layout.tsx`に定義します。
- **ページ遷移:** 内部リンクには必ず`<Link>`コンポーネントを使用し、クライアントサイドナビゲーションを有効にします。
- **動的ルート:** `[id]` や `[...slug]` を使用して動的ルートを定義します。
- **ルートグループ:** `(folder)` を使用してルートに影響しないフォルダ構造を作成します。

### コンポーネント

- **サーバーコンポーネントとクライアントコンポーネントの分離:**
  - **原則:** `page.tsx`や`layout.tsx`は、可能な限りサーバーコンポーネントとして維持します。これにより、初期ロードパフォーマンスが向上します。
  - **ベストプラクティス:** `useState`, `useEffect`などのフックや、イベントリスナーといったインタラクティブな機能を必要とする部分は、独立したクライアントコンポーネント（例: `SignInForm.tsx`）に切り出します。そのファイルの先頭に`'use client'`を宣言してください。
  - **データ取得:** データ取得やバックエンド処理への直接アクセスは、サーバーコンポーネントで行います。

### データ管理

- **データ取得:** データ取得は`async/await`を伴う`fetch` API を使い、サーバーコンポーネント内で行います。
- **データ更新:** データの作成、更新、削除はサーバーアクション (`'use server'`) を使用します。
- **キャッシング:** Next.js の自動キャッシュを活用します。オンデマンドでのキャッシュ更新には`revalidatePath`や`revalidateTag`を使用します。
- **Suspense の活用:** データローディング状態の管理には`<Suspense>`と`loading.tsx`を使用します。

### UI とアセット

- **スタイリング:** スタイリングには`styled-components`を使用します。
- **画像最適化:** `next/image`の`<Image>`コンポーネントを使用して、画像の自動最適化を行います。
- **フォント最適化:** `next/font`を利用して Web フォントを最適化し、パフォーマンスを向上させます。

### エラーハンドリングと SEO

- **エラー処理:** `error.tsx`でエラー UI 境界を定義し、`not-found.tsx`で 404 ページをハンドリングします。
- **メタデータ:** `generateMetadata`関数を用いて、動的なメタデータや OG 画像を生成し、SEO を強化します。

## Next.js アンチパターン (実装禁止)

- **手動でのプロジェクトセットアップ:** `create-next-app` を使わず、手動で Next.js プロジェクトを構築することは避けます。
- **Pages Router の新規採用:** 新規プロジェクトで古い Pages Router を選択することはしません。
- **相対パスによる深いインポート:** `../../../` のような深い階層の相対パスでのインポートは禁止します。
- **リンター（ESLint）の未導入:** ESLint を導入しない、または設定をスキップすることは許可されません。
- **クライアントコンポーネントでのデータ取得:** サーバーコンポーネントで取得できるデータを、クライアントコンポーネントで取得することは避けます。
- **安易な`'use client'`の使用:** インタラクティブな部分をコンポーネントとして切り出せるにも関わらず、`page.tsx`全体をクライアントコンポーネントにすることは、パフォーマンスの観点から禁止します。
- **`<a>`タグによる内部リンク:** アプリケーション内のページ遷移にアンカータグ (`<a>`) を使用し、フルページリロードを発生させることは禁止です。必ず`<Link>`コンポーネントを使用してください。
- **最適化されていない画像・フォント:** 標準の`<img>`タグや手動でのフォントリンクを使用せず、Next.js の最適化機能を活用します。
- **エラー処理の欠如:** `error.tsx`や`not-found.tsx`を定義せず、デフォルトのエラー表示に頼ることは避けます。
- **直接的な DOM 操作:** `document.getElementById`などの直接的な DOM 操作は避け、React の宣言的なアプローチを使用します。

## React ベストプラクティス

### コンポーネント設計

- **関数コンポーネントの使用:** 新しいコンポーネントは関数コンポーネントで作成します。
- **単一責任の原則:** 各コンポーネントは単一の責任を持つように設計します。
- **Props の型定義:** TypeScript を使用して Props の型を明確に定義します。
- **デフォルト Props:** 必要に応じて`defaultProps`またはデフォルト引数を使用します。
- **コンポーネントの合成:** 継承よりも合成を優先します。

### Hooks の使用

- **適切な Hook の選択:** 状態管理には`useState`、副作用には`useEffect`を使用します。
- **カスタム Hooks:** 再利用可能なロジックはカスタム Hooks に抽出します。
- **依存配列の管理:** `useEffect`、`useMemo`、`useCallback`の依存配列を適切に管理します。
- **パフォーマンス最適化:** `useMemo`と`useCallback`を適切に使用してパフォーマンスを最適化します。

### 状態管理

- **ローカル状態の優先:** グローバル状態よりもローカル状態を優先します。
- **状態の正規化:** 複雑な状態は正規化して管理します。
- **不変性の維持:** 状態更新時は不変性を維持します。

## React アンチパターン (実装禁止)

- **クラスコンポーネントの新規作成:** 新しいコンポーネントでクラスコンポーネントを使用することは禁止します。
- **直接的な状態変更:** `state.push()`のような直接的な状態変更は禁止します。
- **useEffect の無限ループ:** 依存配列を適切に設定せず、無限ループを引き起こすことは避けます。
- **過度な re-render:** 不適切な状態管理によるパフォーマンス問題を避けます。
- **key prop の不適切な使用:** リストレンダリング時に index を key として使用することは避けます。

## TypeScript ベストプラクティス

### 型定義

- **厳密な型設定:** `tsconfig.json`で`strict: true`を設定します。
- **明示的な型注釈:** 関数の戻り値や複雑な変数には明示的な型注釈を付けます。
- **インターフェースの活用:** オブジェクトの形状定義には interface を使用します。
- **ユニオン型の活用:** 複数の可能な型を表現する際はユニオン型を使用します。
- **ジェネリクスの使用:** 再利用可能な型定義にはジェネリクスを使用します。

### 型安全性

- **any 型の回避:** `any`型の使用は最小限に抑えます。
- **型ガードの実装:** 実行時の型チェックには型ガードを実装します。
- **null チェック:** `strictNullChecks`を有効にし、適切な null チェックを行います。

## TypeScript アンチパターン (実装禁止)

- **any 型の乱用:** 型安全性を損なう`any`型の過度な使用は禁止します。
- **型アサーションの乱用:** `as`キーワードの不適切な使用は避けます。
- **非 null アサーション演算子の乱用:** `!`演算子の過度な使用は避けます。

## Jest ベストプラクティス

### テスト構造

- **AAA パターン:** Arrange、Act、Assert の構造でテストを記述します。
- **記述的なテスト名:** テストの目的が明確になるような名前を付けます。
- **単一の責任:** 各テストは単一の機能をテストします。
- **テストの独立性:** テスト間の依存関係を避けます。

### モックとスタブ

- **適切なモック:** 外部依存関係は適切にモックします。
- **jest.fn()の活用:** 関数のモックには`jest.fn()`を使用します。
- **モックのクリア:** `beforeEach`でモックをクリアします。

### React Testing Library との連携

- **ユーザー中心のテスト:** ユーザーの操作に基づいたテストを記述します。
- **適切なクエリの使用:** `getByRole`、`getByLabelText`などの適切なクエリを使用します。
- **非同期テスト:** `waitFor`、`findBy`を使用して非同期処理をテストします。

### カバレッジ

- **適切なカバレッジ:** 重要な機能に対して適切なテストカバレッジを維持します。
- **カバレッジレポート:** `--coverage`フラグを使用してカバレッジレポートを生成します。

## Jest アンチパターン (実装禁止)

- **実装詳細のテスト:** コンポーネントの内部実装ではなく、ユーザーの体験をテストします。
- **過度なモック:** 必要以上にモックを作成することは避けます。
- **テストの重複:** 同じ機能を複数回テストすることは避けます。
- **非決定的テスト:** 実行のたびに結果が変わるテストは作成しません。

## Playwright ベストプラクティス

### テスト設計

- **Page Object Model:** 再利用可能なページオブジェクトを作成します。
- **独立したテスト:** 各テストは独立して実行可能にします。
- **適切な待機:** 要素の表示を適切に待機します。
- **並列実行:** テストの並列実行を活用してテスト時間を短縮します。

### セレクタ戦略

- **安定したセレクタ:** `data-testid`などの安定したセレクタを使用します。
- **ロケータの活用:** Playwright のロケータ API を活用します。
- **テキストベースの選択:** 可能な限りテキストベースでの要素選択を行います。

### テスト環境

- **複数ブラウザでのテスト:** Chrome、Firefox、Safari でのクロスブラウザテストを実施します。
- **モバイルテスト:** モバイルデバイスでのテストも実施します。
- **スクリーンショット:** 失敗時のスクリーンショットを自動取得します。

### パフォーマンス

- **ネットワーク待機:** ネットワークリクエストの完了を適切に待機します。
- **リソースの最適化:** 不要なリソースの読み込みを避けます。

## Playwright アンチパターン (実装禁止)

- **脆弱なセレクタ:** CSS クラス名や XPath に依存したセレクタの使用は避けます。
- **固定的な待機:** `page.waitForTimeout()`のような固定時間の待機は避けます。
- **テスト間の依存:** テストの実行順序に依存した設計は避けます。
- **過度な詳細テスト:** UI の細かい詳細よりもユーザーフローに焦点を当てます。
- **認証の重複:** 各テストで認証を繰り返すことは避け、認証状態の保存を活用します。

## 共通ガイドライン

### コード品質

- **一貫したコーディングスタイル:** ESLint と Prettier を使用して一貫したスタイルを維持します。
- **適切なコメント:** 複雑なロジックには適切なコメントを記述します。
- **リファクタリング:** 定期的なリファクタリングでコード品質を維持します。

### セキュリティ

- **入力値の検証:** すべての入力値を適切に検証します。
- **XSS 対策:** ユーザー入力の適切なエスケープを行います。
- **認証・認可:** 適切な認証・認可機能を実装します。

### パフォーマンス

- **バンドルサイズの最適化:** 不要なライブラリの削除とコード分割を実施します。
- **画像最適化:** 適切な画像フォーマットとサイズを使用します。
- **キャッシュ戦略:** 適切なキャッシュ戦略を実装します。
